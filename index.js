#!/usr/bin/env node

const { execSync } = require('child_process');
const fs = require('fs-extra');
const path = require('path');
const prompts = require('prompts');
const validateName = require('validate-npm-package-name');

const { name, version } = require(path.join(__dirname, './package.json'));

const appDir = path.join(__dirname, `./package/stable`);
const appPackage = require(path.join(appDir, 'package.json'));

console.log(`이 시스템은 Create-Discord-bots CLI 로 제작중입니다..`)
console.log(`ENTER 누를 시 기본설정으로 척용됩니다.`)
console.log(`응답이 없을시 ^C를 눌러주세요`)
console.log(`버전 : V${version}`)
const getApplicationId = (token) => {
	try {
		/** @type {string} */
		const response = execSync(
			`curl -s -X GET -H "Authorization: Bot ${token}" "https://discord.com/api/oauth2/applications/@me"`
		).toString();
		const parsedResponse = JSON.parse(response);

		return parsedResponse.id || null;
	} catch {
		return null;
	}
};


prompts([
	{
		type: 'text',
		name: 'name',
		initial: appPackage.name,
		validate: (/** @type {string} */ name) => {
			const { validForNewPackages, errors, warnings } = validateName(name);
			return validForNewPackages || `Error: ${(errors || warnings).join(', ')}.`;
		},
		message: 'Application name?',
	},
])
	.then(async (/** @type {{ name: string }} */ { name }) => {
		const utilityNameAndVersion = `${name} v${version}`;
		const dir = path.resolve(name);
		const isUpdate = fs.existsSync(dir);
		/** @type {Step[]} */
		let steps;
		const { type } = prompts([
			{
				type: 'text',
				name: 'type',
				initial: 'TYPE',
				message: 'Application types? (Stable)',
			},
		]);
		
		if (isUpdate) {
			/** @type {{ update: boolean }}  */
			const { update } = await prompts([
				{
					type: 'confirm',
					name: 'update',
					message: `Directory '${dir}' already exists. Do you want to update it?`,
				},
			]);

			if (!update) {
				console.log();
				throw 'Quitting...';
			}

			steps = [
				{
					message: `Updating core files in '${name}'...`,
					action: () => {
						fs.copySync(`${appDir}/${types}`, `${dir}`);
					},
					ignoreDry: false,
				},
			];
		} else {
			/** @type {{ token: string }} */
			const { token } = await prompts([
				{
					type: 'password',
					name: 'token',
					initial: 'DISCORD_BOT_TOKEN_PLACEHOLDER',
					message: 'Discord bot token?',
				},
			]);

			steps = [
				{
					message: `Creating directory '${name}'...`,
					action: () => fs.mkdirSync(dir),
					ignoreDry: false,
				},
				{
					message: 'Creating boilerplate...',
					action: () => {
						fs.copySync(appDir, dir);
						fs.writeFileSync(path.join(dir, '.gitignore'), 'node_modules/\n.env\n');
					},
					ignoreDry: false,
				},
				{
					message: 'Updating package.json...',
					action: () => {
						const description = `Generated by ${utilityNameAndVersion}.`;
						const newPackage = { ...appPackage, name, description };
						fs.writeFileSync(
							path.join(dir, 'package.json'),
							`${JSON.stringify(newPackage, null, 2)}\n`
						);
					},
					ignoreDry: false,
				},
				{
					message: 'Writing .env...',
					action: () =>
						fs.writeFileSync(path.join(dir, '.env'), `DISCORD_BOT_TOKEN=${token}`),
					ignoreDry: false,
				},
				{
					message: 'Installing modules...',
					action: () => {
						process.chdir(dir);
						execSync('npm ci');
					},
					ignoreDry: false,
				},
				{
					message: '\nGenerating bot invite link...',
					ignoreDry: true,
					action: () => {
						const applicationId = getApplicationId(token);
						console.log(
							applicationId
								? `Invite your bot: https://discord.com/oauth2/authorize?scope=bot&client_id=${applicationId}`
								: 'The given bot token was invalid so no invite link was generated.'
						);
					},
				},
			];
		}

		const [, , ...args] = process.argv;
		const isDryRun = args[0] === '--dry-run';

		console.log();
		steps.forEach(({ message, ignoreDry, action }) => {
			console.log(message);
			if (ignoreDry || !isDryRun) {
				action();
			}
		});

		console.log();
		console.log(`Done!\n\nStart by running:\n\t$ cd ${name}/\n\t$ npm start`);
		process.exit(0);
	})
	.catch(console.error);